<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Angular学习4 | 保的城</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="代理模式(proxy)继续上一篇的学习

代理：指一个类可以作为其他东西的接口。代理者可以作任何东西的接口：网络连接，存储器中的大对象，文件或者其他昂贵或无法复制的资源。

代理可以分为三种类型：

虚拟代理（Virtual Proxy）
远端代理（Remote Proxy）
保护代理（Protection Proxy）

我们讨论虚拟代理在AngularJS中的实现
下面的代码调用$get函数，">
<meta property="og:type" content="article">
<meta property="og:title" content="Angular学习4">
<meta property="og:url" content="http:www.balsam.xyz/2015/12/angular-learn-4/index.html">
<meta property="og:site_name" content="保的城">
<meta property="og:description" content="代理模式(proxy)继续上一篇的学习

代理：指一个类可以作为其他东西的接口。代理者可以作任何东西的接口：网络连接，存储器中的大对象，文件或者其他昂贵或无法复制的资源。

代理可以分为三种类型：

虚拟代理（Virtual Proxy）
远端代理（Remote Proxy）
保护代理（Protection Proxy）

我们讨论虚拟代理在AngularJS中的实现
下面的代码调用$get函数，">
<meta property="og:updated_time" content="2015-12-23T07:03:48.373Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Angular学习4">
<meta name="twitter:description" content="代理模式(proxy)继续上一篇的学习

代理：指一个类可以作为其他东西的接口。代理者可以作任何东西的接口：网络连接，存储器中的大对象，文件或者其他昂贵或无法复制的资源。

代理可以分为三种类型：

虚拟代理（Virtual Proxy）
远端代理（Remote Proxy）
保护代理（Protection Proxy）

我们讨论虚拟代理在AngularJS中的实现
下面的代码调用$get函数，">
  
    <link rel="alternative" href="/atom.xml" title="保的城" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Balsam</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Program | Design | Humor</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/balsamleo" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/no20lbc" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/liao-bao-cheng" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="https://balsamleo@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/30天js/" style="font-size: 20px;">30天js</a> <a href="/tags/Angular/" style="font-size: 15px;">Angular</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/职业生涯/" style="font-size: 10px;">职业生涯</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我，Learn By Using it.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Balsam</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Balsam</h1>
			</hgroup>
			
			<p class="header-subtitle">Program | Design | Humor</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/balsamleo" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/no20lbc" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/liao-bao-cheng" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="https://balsamleo@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-angular-learn-4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/angular-learn-4/" class="article-date">
  	<time datetime="2015-12-23T06:47:02.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Angular学习4
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Angular/">Angular</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="代理模式(proxy)">代理模式(proxy)</h3><p>继续<a href="http://www.balsam.xyz/2015/12/angular-learn-3/" target="_blank" rel="external">上一篇</a>的学习</p>
<blockquote>
<p>代理：指一个类可以作为其他东西的接口。代理者可以作任何东西的接口：网络连接，存储器中的大对象，文件或者其他昂贵或无法复制的资源。</p>
</blockquote>
<p>代理可以分为三种类型：</p>
<ul>
<li>虚拟代理（Virtual Proxy）</li>
<li>远端代理（Remote Proxy）</li>
<li>保护代理（Protection Proxy）</li>
</ul>
<p>我们讨论虚拟代理在AngularJS中的实现</p>
<p>下面的代码调用<code>$get</code>函数，属于一个名为User的<code>$resource</code>的实例<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var User = <span class="variable">$resource</span>(<span class="string">'/users/:id'</span>),</span><br><span class="line">	user = User.get(&#123; id: <span class="number">42</span> &#125;);</span><br><span class="line">console.log(user);//&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>console输出一个空对象。当User.get被执行时，幕后所对应的Ajax请求是异步运行。当console.log调用时，我们尚未获取user的内容。User.get发出get请求只会，立即返回一个空对象，并保留指向该对象的引用。我们可以将这个对象想象成一个虚拟代理(简单的占位器)。当客户端稍后从服务器收到响应时，再将实际数据植入此代理对象。</p>
<p>AngularJS的实现如下：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> MainCtrl(<span class="variable">$scope</span>, <span class="variable">$resource</span>)&#123;</span><br><span class="line">	var User = <span class="variable">$resource</span>(<span class="string">'/users/:id'</span>),</span><br><span class="line">	<span class="variable">$scope</span>.user = User.get(&#123; id: <span class="number">42</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;span ng-bind=<span class="string">"user.name"</span>&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<p>最上面的代码最初执行时，<code>$scope</code>对象内的user属性被赋值为一个空对象{}，以为者user.name值是undefined，网页也不渲染任何内容。AngularJS内部保留一份对此对象的引用。一旦服务器返回对get请求的响应，AngularJS会将来自服务器的数据植入此对象。下一次<code>$digest</code>循环中，AngularJS会探测到<code>$scope.user</code>的变化，然后更新页面。</p>
<h3 id="Active_Record模式">Active Record模式</h3><blockquote>
<p>Active Record是一种包含数据和行为的对象。通常这些对象中的大部分数据都是持久的。Active Record对象负责处理与数据库的交互，实现创建/更新/接收/删除数据。它也可能将这些任务交给更底层的对象区完成，但数据库依然是通过调用active record对象实例或静态方法来发起。</p>
</blockquote>
<p>AngularJS定义了一种<code>$resource</code>的service。根据AngularJS文档，定义是：</p>
<blockquote>
<p>一个用来创建资源对象的factory，其功能是与RESTful服务器数据源进行交互操作。其返回的资源对象中包含一些提供高层级服务的action方法，而无需使用低层级的<code>$http</code>服务。</p>
</blockquote>
<p><code>$resource</code>按如下方式使用<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var User = <span class="variable">$resource</span>(<span class="string">'/users/:id'</span>),</span><br><span class="line">	user = new User(&#123;</span><br><span class="line">		name: <span class="string">'foo'</span>,</span><br><span class="line">		age: <span class="number">42</span></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">user.<span class="variable">$save</span>();</span><br></pre></td></tr></table></figure></p>
<p>调用<code>$resource</code>会给模型实例创建一个构造函数。每个模型实例都包含用于不同CRUD操作的方法函数。<br>我们可以用下面的形式来使用构造函数和其静态方法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">User</span><span class="class">.get</span>(<span class="rules">&#123; <span class="rule"><span class="attribute">userid</span>:<span class="value"> userid </span></span></span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上代码会立即返回一个空对象并保留指向该对象的引用。当响应成功并解析后，AngularJS会将收到的数据植入该对象(参见代理模式)。<br>更多有关<code>$resource</code>的内容<a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank" rel="external">参考文档</a></p>
<h3 id="截取筛选器模式(Intercepting_Filters)">截取筛选器模式(Intercepting Filters)</h3><blockquote>
<p>创建可组合的筛选器链条来完成网页请求过程中常用的预处理和后处理任务。</p>
</blockquote>
<p>很多情况下，需要对HTTP请求进行各种预处理和后处理工作。使用截取筛选器，可以根据给定的HTTP请求/响应的头部和正文内容来处理，加入相应的日志/安全和其他信息。截取筛选器模式包含一个筛选器链条，按照给定的顺序对数据进行处理。每节筛选器的输出是下一节的输入。</p>
<p>AngularJS在<code>$httpProvider</code>中实现了截取筛选器。<code>$httpProvider</code>拥有一个名为interceptors的数组，其中包含一组对象。每个对象拥有以下属性：request，response，requestError和responseError。</p>
<p>requestError是一个截取器，之前的request截取器抛出错误或者被拒绝时就会调用requestError。responseError则是response截取器抛出错误时调用。</p>
<p>以下是一个使用对象字面量(object literal)添加截取器的例子：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$httpProvider</span>.interceptors.push(<span class="keyword">function</span>(<span class="variable">$q</span>,dependency1,dependency2)&#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		<span class="string">'request'</span>: function(config)&#123;</span><br><span class="line">			//same as above</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">'response'</span>:function(response)&#123;</span><br><span class="line">			//same as above</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Directives">Directives</h2><h3 id="组合模式(Composite)">组合模式(Composite)</h3><blockquote>
<p>组合模式是一种树状结构设计模式，将一组相似的对象与一个单一的对象实例一致对待。此模式的意图是将对象组合成树形结构以实现整体-部分。</p>
</blockquote>
<p>GOF描述下，MVC实际上是以下部件的组合：</p>
<ul>
<li>策略模式Strategy</li>
<li>组合模式Composite</li>
<li>观察者模式Observer</li>
</ul>
<p>页面即是各部件的组合。非常类似地，AngularJS中的页面就是由directive和其对应的DOM元素所形成的组合。</p>
<p>例子：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">zippy</span> <span class="attribute">title</span>=<span class="value">"Zippy"</span>&gt;</span></span><br><span class="line">      Zippy!</span><br><span class="line">    <span class="tag">&lt;/<span class="title">zippy</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">myModule.directive('zippy',function()&#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		restrict: 'E',</span><br><span class="line">		template: '<span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"header"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"content"</span> <span class="attribute">ng-transclude</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>',</span><br><span class="line">		link: function(scope,el)&#123;</span><br><span class="line">			el.find('.header').click(function()&#123;</span><br><span class="line">				el.find('.content').toggle();</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上例子定义了一个简单的directive，其功能是一个UI构件。此构件zippy包含头部结构和正文内容。点击头部会切换正文部分显示或隐藏。</p>
<p>从第一个例子可见，整个DOM树是很多元素形成的组合。根组件是html，接着是head和body等。</p>
<p>第二个例子可见，此directive的template属性包含了ng-transclude directive标记。因此，在zippy directive中存在另一个ng-transclude directive。理论上我们可以无限嵌套浙西组件知道抵达叶节点（leaf node)。</p>
<h3 id="解释器模式Interpreter">解释器模式Interpreter</h3><blockquote>
<p>解释器模式是一种对计算机语言的语句进行解释估值的设计模式。基本理念是：给每个终结符或非终结符表达式赋予一个类结构。一个语句的语法树就是一个对该语句进行解释的组合模式的结构实例。</p>
</blockquote>
<p>在AngularJS的<code>$parse</code> service背后，提供了一个DSL(领域专用语言)语言解释器实例。此DSl是一个精简修改版的Javascript。Javascript表达式与AngularJS表达式之间的区别是：</p>
<ul>
<li>可以包含Unix类管道语法的筛选器</li>
<li>不抛出任何错误</li>
<li>不含任何控制流语句（异常，循环，条件语句，可以使用三元运算符）</li>
<li>特定的上下文环境中进行解析估值（当前<code>$scope</code>的上下文）</li>
</ul>
<p><code>$parse</code> service中定义了两个主要的组件：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Responsible for converting given string into tokens.</span></span><br><span class="line"><span class="keyword">var</span> Lexer;</span><br><span class="line"><span class="comment">//Responsible for parsing the tokens and evaluating expression</span></span><br><span class="line"><span class="keyword">var</span> Parser;</span><br></pre></td></tr></table></figure></p>
<p>当给定的表达式被分词后，出于性能需求会被内部缓存。</p>
<p>AngularJS DSL的终结符表达式定义如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> OPERATORS = &#123;</span><br><span class="line">  <span class="comment">/* jshint bitwise : false */</span></span><br><span class="line">  <span class="string">'null'</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;,</span><br><span class="line">  <span class="string">'true'</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;,</span><br><span class="line">  <span class="string">'false'</span>:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;,</span><br><span class="line">  undefined:noop,</span><br><span class="line">  <span class="string">'+'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;,</span><br><span class="line">  <span class="string">'*'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)*b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'/'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)/b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'%'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)%b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'^'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)^b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'='</span>:noop,</span><br><span class="line">  <span class="string">'==='</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a, b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)===b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'!=='</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a, b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)!==b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'=='</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)==b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'!='</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)!=b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'&lt;'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)&lt;b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'&gt;'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)&gt;b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'&lt;='</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)&lt;=b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'&gt;='</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)&gt;=b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'&amp;&amp;'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)&amp;&amp;b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'||'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)||b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'&amp;'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> a(<span class="keyword">self</span>, locals)&amp;b(<span class="keyword">self</span>, locals);&#125;,</span><br><span class="line">  <span class="string">'|'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a,b)</span></span>&#123;<span class="keyword">return</span> b(<span class="keyword">self</span>, locals)(<span class="keyword">self</span>, locals, a(<span class="keyword">self</span>, locals));&#125;,</span><br><span class="line">  <span class="string">'!'</span>:<span class="function"><span class="keyword">function</span><span class="params">(self, locals, a)</span></span>&#123;<span class="keyword">return</span> !a(<span class="keyword">self</span>, locals);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以将每个终结符所属函数看成AbstractExpression接口的实现。</p>
<p>每个Client在一个特定的上下文和作用域中解释给定的AngularJS表达式。</p>
<p>以下是一个AngularJS表达式的例子：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//toUpperCase filter <span class="keyword">is</span> applied to the <span class="literal">result</span> <span class="keyword">of</span> the expression</span><br><span class="line">// (foo) bar:baz </span><br><span class="line">(foo) ? bar : baz | toUpperCase </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 模板视图模式(Template View)</span></span><br><span class="line"></span><br><span class="line">&gt;模板视图是在<span class="type">HTML</span>页面中嵌入标签符号将信息渲染成<span class="type">HTML</span>形式。</span><br><span class="line"></span><br><span class="line">渲染动态页面不是简单的事情，包含大量字符串的连接/修改等操作。创建动态页面最简单的办法是编写自己的标记符号并在其中嵌入表达式。稍后在给定的上下文中对这些表达式进行解析，从而将整个模板编译成其最终格式，也就是<span class="type">HTML</span>(<span class="type">DOM</span>)格式。这就是模板引擎的功用-提取指定的<span class="type">DSL</span>，在恰当的上下文中进行解析，并转换成最终格式。</span><br><span class="line"></span><br><span class="line">模板是一种常用技术，尤其在后端应用中。可以将<span class="type">PHP</span>代码嵌入到<span class="type">HTML</span>中形成动态页面，使用eRuby将<span class="type">Ruby</span>代码嵌入到静态页面中。</span><br><span class="line"></span><br><span class="line">适用于<span class="type">Javascript</span>的模板引擎很多，例如mustache.js/handlebars等。大部分引擎都是将模板以字符串的方式进行操作。模板可以存放在不同的位置：一是静态文件，其可以通过<span class="type">Ajax</span>方式获取；二是以script形式嵌入到视图中，内嵌在javascript中。</span><br><span class="line">例如：</span><br></pre></td></tr></table></figure></p>
<p><script type="template/mustache"><br>  <h2>Names</h2><br>  <br>    <strong></strong><br>  <br></script><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">模板引擎在一个给定的上下文中编译此字符串，将其转换成<span class="tag">DOM</span>元素。如此一来，所有嵌在标记符中的表达式都会被解析，替换成计算值。</span><br><span class="line"></span><br><span class="line">例如，以<span class="rules">&#123; <span class="rule"><span class="attribute">names</span>:<span class="value"> [<span class="string">'foo'</span>,<span class="string">'bar'</span>,<span class="string">'baz'</span>] </span></span></span>&#125;对象为上下文对上面的模板进行解析可以得到：</span><br></pre></td></tr></table></figure></p>
<p></p><h2>Names</h2><br>  <strong>foo</strong><br>  <strong>bar</strong><br>  <strong>baz</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AngularJS模板实际上就是HTML，而不是其他传统模板所使用的中间层格式。AngularJS编译器会遍历DOM树并搜索已知的<span class="function"><span class="title">directive</span><span class="params">(适用与元素/属性/类/注释)</span></span>。当AngularJS找到任何directive，就会调用其所属的逻辑代码，在当前作用域的上下文中解析其中的表达式。</span><br><span class="line"></span><br><span class="line">例如：</span><br></pre></td></tr></table></figure><p></p>
<ul ng-repeat="name in names"><br>  <li></li><br></ul>

<p>$scope.names = [‘foo’,’bar’,’baz’];<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">会生成和上面相同的结果。区别是，模板是包装在HTML中，而非script标签之间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Scope</span><br><span class="line"></span><br><span class="line">### 观察者模式</span><br><span class="line">&gt;一个目标对象管理它的订阅者，并在本身状态改变时主动发出通知。也叫实时事件处理系统。</span><br><span class="line"></span><br><span class="line">AngularJS中<span class="keyword">scope</span>之间有两种互相通信的方式。</span><br><span class="line">一是在子<span class="keyword">scope</span>中调用父<span class="keyword">scope</span>的函数方法，这是基于子<span class="keyword">scope</span>与其父母的原型继承关系。这种方式允许单向通信-从子到父。有些时候也需要在父<span class="keyword">scope</span>的上下文中调用子<span class="keyword">scope</span>的函数方法或者通知其触发事件。基于此需求，AngularJS内置了一种观察者模式。</span><br><span class="line">观察者模式的另一个使用场景是：如果多个<span class="keyword">scope</span>都关注某个事件，但该事件触发上下文对应的<span class="keyword">scope</span>与其它<span class="keyword">scope</span>无关系，可以切断不同<span class="keyword">scope</span>之间的耦合关系，形成独立的存在。</span><br><span class="line"></span><br><span class="line">每个AngularJS <span class="keyword">scope</span>都有公有函数 <span class="string">`$on`</span>,<span class="string">`$emit`</span>,<span class="string">`$broadcast`</span>。</span><br><span class="line"><span class="string">`$on`</span>函数接受事件主题为第一参数，事件回调为第二参数。我们可以将回调函数看成是一个观察者。即实作Observer接口的对象(因为Javascript的头等函数特性，我们只需提供notify函数方法的实现)。</span><br></pre></td></tr></table></figure></p>
<p>function ExampleCtrl($scope){<br>    $scope.$on(‘event-name’,function handler(){<br>        //body<br>    });<br>}<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这种方式中，当前scope会【订阅】类别为event-name的事件。当event-name在任何父scope或子scope中被触发后，handler将被调用。</span><br><span class="line"></span><br><span class="line">`<span class="variable">$emit</span>`和`<span class="variable">$broadcast</span>`函数分别被用于在scope链中向上后向下触发事件。例如：</span><br></pre></td></tr></table></figure></p>
<p>function ExampleCtrl($scope){<br>    $scope.$emit(‘event-name’,{ foo: ‘bar’ });<br>}<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">例子中的<span class="keyword">scope</span>会向上方的<span class="keyword">scope</span>触发event-name事件。所有订阅了event-name事件的父<span class="keyword">scope</span>都会得到通知并执行handler回调函数。</span><br><span class="line"></span><br><span class="line"><span class="string">`$broadcast`</span>函数调用与此类似。唯一的区别是事件向下传递给所有子$<span class="keyword">scope</span>。每个<span class="keyword">scope</span>可以给任何事件订阅配属多个回调函数（即：一个给定事件对应多个观察者)。</span><br><span class="line"></span><br><span class="line">这种模式称为发布/订阅模式。</span><br><span class="line">更多实战例子可见本文<span class="string">`观察者模式作为外部服务`</span>章节。</span><br><span class="line"></span><br><span class="line">### 责任链模式</span><br><span class="line"></span><br><span class="line">&gt;包含一些命令对象和一系列处理对象。每一个处理对象决定它能处理哪些命令对象，也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。</span><br><span class="line"></span><br><span class="line">AngularJS应用中的<span class="keyword">scope</span>组成了一个层级结构，称为<span class="keyword">scope</span>链。有些<span class="keyword">scope</span>是独立的，指的是它们不从父<span class="keyword">scope</span>进行原型继承，而是通过<span class="string">`$parent`</span>属性进行连接。</span><br><span class="line"></span><br><span class="line">当调用<span class="string">`$emit`</span>或者<span class="string">`$broadcast`</span>时，我们可以将<span class="keyword">scope</span>链看作事件传递总线，更精确的说法是责任链。某个事件被触发时，无论是向上还是向下传递(基于调用不同的函数方法)，链条中紧随的<span class="keyword">scope</span>可能会有如下的操作：</span><br><span class="line">- 处理该事件并传递给链条中的下一环</span><br><span class="line">- 处理该事件并终止传递</span><br><span class="line">- 不处理事件，直接将事件传递给下一环</span><br><span class="line">- 不处理事件，并终止传递</span><br><span class="line"></span><br><span class="line">从下面的例子可以看到ChildCtrl触发了一个在<span class="keyword">scope</span>链条中向上传递的事件。每个父<span class="keyword">scope</span>(ParentCtrl和MainCtrl中的<span class="keyword">scope</span>)将处理此事件，在console中输出<span class="string">"foo received"</span>。如果某个<span class="keyword">scope</span>被认为是最终目标，则可以在此调用事件对象(即回调函数中传递的参数)的stopPropagation方法。</span><br></pre></td></tr></table></figure></p>
<p>myModule.controller(‘MainCtrl’,function($scope){<br>    $scope.$on(‘foo’,function(){<br>        console.log(‘foo received’);<br>    });<br>});</p>
<p>myModule.controller(‘ParentCtrl’,function($scope){<br>    $scope.$on(‘foo’,function(e){<br>        console.log(‘foo received’);<br>    });<br>});</p>
<p>myModule.controller(‘ChildCtrl’,function($scope){<br>    $scope.$emit(‘foo’);<br>});<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面这些被注入到controller中的scope就是handler。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 命令模式Command</span></span><br><span class="line"></span><br><span class="line">&gt;以物件来代表并封装所有用于在稍后某个时间调用一个函数方法所需要的信息。此信息包括所要调用的函数名称<span class="pi">/宿主/</span>参数值。</span><br><span class="line"></span><br><span class="line">在继续讨论命令模式之前，我们看看AngularJS如何实现数据绑定的。</span><br><span class="line"></span><br><span class="line">当我们需要将模型和视图绑定时，可以使用ng-bind（单项数据绑定）或ng-model(双向数据绑定)。下面的代码可以将foo模型中的每个变化反映到视图中：</span><br></pre></td></tr></table></figure></p>
<p><span ng-bind="foo"></span><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每当我们改变foo值时，span中的inner <span class="type">text</span>会随之改变。我们可以使用AngularJS表达式来实现更复杂的同类效果。例如：</span><br></pre></td></tr></table></figure></p>
<p><span ng-bind="foo + ' ' + bar | uppercase"></span><br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面例子中，span内的文本值等于foo和bar的值串联后再转成大写字母。让我们看看幕后发生了什么。</span><br><span class="line"></span><br><span class="line">每个`<span class="variable">$scope</span>`都含有名为`<span class="variable">$watch</span>`的函数方法。当AngularJS编译器找到ng-bind时，会为`foo+<span class="string">' '</span> + bar | uppercase`表达式创建一个新的监视器，也就是`<span class="variable">$scope</span>.<span class="variable">$watch</span>(<span class="string">"foo + ' ' + bar | uppercase"</span>, <span class="keyword">function</span> () &#123; /* body */ &#125;);`。每当表达式值改变时，监视器中的回调函数就会触发。回调更新span的文本。</span><br></pre></td></tr></table></figure></p>
<p>$watch: function(watchExp,listener,objectEquality){<br>    var scope = this,<br>            get = compileToFn(watchExp,’watch’),<br>            array = scope.$$watchers,<br>            watcher = {<br>                fn: listener,<br>                last: initWatchVal,<br>                get: get,<br>                exp: watchExp,<br>                eq: !!objectEquality<br>            };<br>    //….<br>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以将watcher对象视为一条命令。该命令的表达式会在每次<span class="escape">`$</span>digest<span class="escape">`循</span>环中被估值。一旦AngularJS发现表达式中的数值改变，就调用listener函数。watcher命令中封装了用以完成以下任务所需的全部信息。任务包括监视所给定的表达式和将命令委托给listener函数(实际接收者)。我们可以将<span class="escape">`$</span>scope<span class="escape">`视</span>为命令的client(客户)，就爱那个<span class="escape">`$</span>digest<span class="escape">`循</span>环视为命令的Invoker(执行者)</span><br><span class="line"></span><br><span class="line">## Controllers</span><br><span class="line"></span><br><span class="line">### 页面控制器模式Page Controller</span><br><span class="line"></span><br><span class="line">&gt;页面控制器指的是用于处理网站上某个特定页面请求或操作的对象。页面控制器模式接受来自页面请求的输入，对具体模型调用所要求的操作，并决定在结果页面所应该使用的正确视图。将调度逻辑从视图相关代码中分离。</span><br><span class="line"></span><br><span class="line">由于不同的页面之间存在大量重复操作(渲染页脚，页眉，用户对话等)，各个页面控制器在一起可以构成一个层级结构。AngularJS中的控制器(controller)有着相对有限的用途。它们不接受用户请求，那是<span class="escape">`$</span>route<span class="escape">`和</span>$state<span class="escape">` </span>service的任务，页面渲染是<span class="escape">`n</span>g-view ui-view<span class="escape">`的</span>责任。</span><br><span class="line"></span><br><span class="line">与页面控制器类似，AngularJS的controller负责处理用户交互操作，提供并更新模型。当模型(model)附在scope上，它就会暴露给页面view使用。基于用户的操作行为，页面会调用已经附着于scope上的相应函数方法。页面控制器与AngularJS controller的另一个相似点则是由它们所组成的层级结构。此结构与scope层级相对应。由此，共通的操作可以被隔离出来并置于基础controller中。</span><br><span class="line"></span><br><span class="line">AngularJS中的controller与ASP.net WebForms背后的代码很像</span><br></pre></td></tr></table></figure></p>
<p>&lt;!doctype html&gt;</p>
<html><br>  <head><br>  </head><br>  <body ng-controller="MainCtrl"><br>    <div ng-controller="ChildCtrl"><br>      <span></span><br>      <button ng-click="click()">Click</button><br>    </div><br>  </body><br></html>


<p>function MainCtrl($scope,$location,User){<br>    if(!User.isAuthenticated()){<br>        $location.path(‘/unauthenticated’);<br>    }<br>}</p>
<p>function ChildCtrl($scope,User){<br>    $scope.click = function(){<br>        alert(“You clicked me!”);<br>    };<br>    $scope.user = User.get(0);<br>}<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此例子描述了一个最简单的通过使用基础控制器来实现重用逻辑的例子。我们不推荐在生产环境中将逻辑置于控制器中，不同路径route的权限可以在更高测抽象层级来判定。</span><br><span class="line"></span><br><span class="line">ChildCtrl负责处理点击<span class="string">"Click"</span>按钮之类的操作，并将模型附在scope上，暴露给页面使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## 其他</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 模块模式</span></span><br><span class="line"></span><br><span class="line">模块模式是Javascript传统模式，主要用来提供封装和私密性。</span><br><span class="line"></span><br><span class="line">可以基于Javascript的函数作用域来实现程序结构的私密性。每个模块可以拥有零个以上私有成员。这些成员都隐藏在函数的本地作用域中。此函数会返回一个对象，用于输出给定模块的公有API</span><br></pre></td></tr></table></figure></p>
<p>var Page = (function(){<br>    var title;</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">setTitle</span>(<span class="params">t</span>)</span>{
    <span class="built_in">document</span>.title = t;
    title = <span class="number">5</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> title;
}

<span class="keyword">return</span> {
    setTitle: setTitle,
    getTitle: getTitle
};
</code></pre><p>}());<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的例子中，我们实现了一个IIFE。别调用后会返回一个拥有两个函数方法的对象，此对象再给<span class="keyword">Page</span>赋值。</span><br><span class="line"></span><br><span class="line">在此处，使用<span class="keyword">Page</span>对象并不能直接修改在IIFE本地作用域内部所定义的title变量。</span><br><span class="line"></span><br><span class="line">模块模式在定义AngularJS中的service时非常有用。使用此模式可以模拟并实现私密性：</span><br></pre></td></tr></table></figure></p>
<p>app.factory(‘foo’,function(){<br>    function privateMember(){<br>        //body…<br>    }</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">publicMember</span><span class="params">()</span></span>{
    <span class="comment">//body;</span>
    privateMemeber();
    <span class="comment">//body;</span>
}

<span class="keyword">return</span>{
    publicMember: publicMember
};
</code></pre><p>});<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">当foo被注入到其他任何组件中时，我们并不能使用其私有函数方法，只能使用公有方法，这种解决方案在搭建可重用的库时极为有用。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 数据映射模式(Data mapper)</span></span><br><span class="line"></span><br><span class="line">&gt;数据映射模式指在持久化数据存储(关系性数据库)与内存数据表述(domain layer)之间执行双向传输的数据存取层。此模式的目的是保持内存中的数据表述和持久化数据存储相互独立，以及数据映射器本身的独立性。</span><br><span class="line"></span><br><span class="line">AngularJS常与API服务器进行数据交流。此服务器是用某种服务器语言（Ruby，PHP，Java，Javascript等）来实现。</span><br><span class="line"></span><br><span class="line">一般来说，如果服务器提供RESTful API，`$resource`可以帮助我们以Active Record类的方式与服务器通讯。尽管在某些应用中，从服务器返回的数据并非是最适合在前端使用的格式。</span><br><span class="line"></span><br><span class="line">我们假设某个应用中，每个用户包含： <span class="number">1.</span><span class="property">name</span>  <span class="number">2.</span>address <span class="number">3.</span><span class="type">list</span> <span class="keyword">of</span> friends</span><br><span class="line"></span><br><span class="line">并且API提供了如下方法：</span><br><span class="line"><span class="number">1.</span>GET /user/:<span class="property">id</span>  返回指定用户的用户名和地址</span><br><span class="line"><span class="number">2.</span>GET /friends/:<span class="property">id</span> 返回指定用户的好友列表</span><br><span class="line"></span><br><span class="line">一种解决方案是使用两个不同的服务。更好的解决方案是提供一个名为User的service，它会在请求某个用户时同时加载该用户的好友</span><br></pre></td></tr></table></figure></p>
<p>app.factory(‘User’, function($q){<br>    function User(name, address, friends){<br>        this.name = name;<br>        this.address = address;<br>        this.friends = friends;<br>    }</p>
<pre><code>User.get = <span class="keyword">function</span>(params){
    var user = <span class="variable">$http</span>.get(<span class="string">'/user'</span> + params.id),
            friends = <span class="variable">$http</span>.get(<span class="string">'/friends'</span> + params.id);
    <span class="variable">$q</span>.all([user,friends])
        .then(function(user, friends){
            return new User(user.name, user.address, friends);
        });
    };
    <span class="keyword">return</span> User;
</code></pre><p>});<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如此一来，我们就创建了一个伪数据映射器，用来使我们的API适应SPA的需求。</span><br><span class="line">我们可以通过以下方式使用<span class="built_ins">User</span>服务：</span><br></pre></td></tr></table></figure></p>
<p>function MainCtrl($scope, User){<br>    User.get({ id: 1})<br>    .then(function( data ){<br>        $scope.user = data;<br>    });<br>}<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如下的模板：</span><br></pre></td></tr></table></figure></p>
<p><div><br>  <div><br>    Name: <br>  </div><br>  <div><br>    Address: <br>  </div><br>  <div><br>    Friends with ids:<br>    <ul><br>      <li ng-repeat="friend in user.friends"></li><br>    </ul><br>  </div><br></div><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### 观察者模式作为外部服务</span></span><br><span class="line"></span><br><span class="line">控制器实例</span><br><span class="line">以下例子展示了如何添加<span class="keyword">attach</span>，通知notify和解除<span class="keyword">detach</span>一个事件</span><br></pre></td></tr></table></figure></p>
<p>angular.module(‘app.controllers’)<br>    .controller(‘ObserverExample’,ObserverExample);<br>ObserverExample.$inject = [‘ObserverService’, ‘$timeout’];</p>
<p>function ObserverExample(ObserverService, $timeout){<br>    var vm = this;<br>    var id = ‘vm1’;</p>
<pre><code>ObserverService.attach(callbackFunction, <span class="string">'let_me_know'</span>, id)

<span class="keyword">function</span> callbackFunction(params){
    console.log(<span class="string">'now i know'</span>);
    ObserverService.notify(<span class="string">'let_me_know'</span>);
}

<span class="variable">$timeout</span>(<span class="keyword">function</span>(){
    ObserverService.notify(<span class="string">'let_me_know'</span>);
},<span class="number">5000</span>);
</code></pre><p>}</p>
<p>另一种移除事件的方式<br>angular.module(‘app.controllers’)<br>    .controller(‘ObserverExample’, ObserverExample);<br>ObserverExample.$inject = [‘ObserverService’, ‘$timeout’, ‘$scope’];</p>
<p>function ObserverExample(ObserverService, $timeout, $scope){<br>    var vm = this;<br>    var id = ‘vm1’;<br>    ObserverService.attach(callbackFunction, ‘let_me_know’, id)</p>
<pre><code><span class="keyword">function</span> callbackFunction(params){
    console.log(<span class="string">'now i know'</span>);
}

<span class="variable">$timeout</span>(<span class="keyword">function</span>(){
    ObserverService.notify(<span class="string">'let_me_know'</span>);
},<span class="number">5000</span>);

<span class="variable">$scope</span>.<span class="variable">$on</span>(<span class="string">'$destory'</span>, <span class="keyword">function</span> handler(){
    ObserverService.detachByEvent(<span class="string">'let_me_know'</span>)
});
</code></pre><p>}<br>```</p>
<h2 id="参考文献">参考文献</h2><ol>
<li><a href="https://en.wikipedia.org/wiki" target="_blank" rel="external">维基百科</a> 本文所有设计模式的简介都引自维基百科。</li>
<li><a href="https://docs.angularjs.org" target="_blank" rel="external">AngularJS 文档</a></li>
<li><a href="https://github.com/angular/angular.js" target="_blank" rel="external">AngularJS 源码库</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/ff649595.aspx" target="_blank" rel="external">页面控制器 (Page Controller)</a></li>
<li><a href="http://martinfowler.com/books/eaa.html" target="_blank" rel="external">企业应用架构模式 (P of EAA)</a></li>
<li><a href="http://googletesting.blogspot.com/2008/05/tott-using-dependancy-injection-to.html" target="_blank" rel="external">Using Dependancy Injection to Avoid Singletons</a></li>
<li><a href="https://stackoverflow.com/questions/13512949/why-would-one-use-the-publish-subscribe-pattern-in-js-jquery" target="_blank" rel="external">Why would one use the Publish/Subscribe pattern (in JS/jQuery)?</a></li>
</ol>
<p><em>抄写完毕，继续我的AngularJS学习之旅，马上要做项目了，鸭子上架</em></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/javascript-learn-5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Javascript学习1223
        
      </div>
    </a>
  
  
    <a href="/2015/12/angular-learn-3/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">AngularJS学习3</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="angular-learn-4" data-title="Angular学习4" data-url="http:www.balsam.xyz/2015/12/angular-learn-4/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"flase"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Balsam
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>